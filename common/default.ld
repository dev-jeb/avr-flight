/**
* @contact_info:
* Author: dev_jeb
* Email: developer_jeb@outlook.com
*
* @purpose:
* A linker script to use with avr-ld.
**/

/**
* Input Object File/s: Object files (.o) that are generated by the assembler and ingested by the linker.
* Output Object File: Object file (commonly refered to as an executable) that is generated by the linker.
*
* A Binary File Descriptor (BFD) backend is used by the linker to interact with the input and output object files.
* A BFD backend consists of a set of functions that are used to read and write object files of different formats.
* The statements below tell the linker which Binary File Descriptor (BFD) backend to use for reading input object
* fils and writing the output object file.
*
* OUTPUT_FORMAT: Specifies the BFD backend to use for writing the output object file (executable).
*
* https://users.informatik.haw-hamburg.de/~krabat/FH-Labor/gnupro/5_GNUPro_Utilities/c_Using_LD/ldLinker_scripts.html#OFF
*
* https://ftp.gnu.org/old-gnu/Manuals/ld-2.9.1/html_node/ld_31.html
**/
OUTPUT_FORMAT("elf32-avr")
OUTPUT_ARCH(avr:5)

/**
* we will explicitly link with the crt.o file found in the 
* /common/ directory (We need this to setup the environment prior to calling main). 
* Notice how we pass the option -L with the path to the common directory in the makefile. 
* The linker search for the crt.o file in the current directory then when not found traverse 
* the directories specified with the -L option.
* 
* @note:
* if you are getting a linker error where this file can not be found ensure you have built
* the crt.o file in the common directory. You can do this by running the make command in the
* common directory.
**/
INPUT (crt.o)

/** 
* define the memory layout of the ATmega328p 
**/
MEMORY
{
  FLASH            (rx)  : ORIGIN = 0x000000, LENGTH = 32K
  SRAM            (rw!x) : ORIGIN = 0x800100, LENGTH = 2K
  EEPROM          (rw!x) : ORIGIN = 0x810000, LENGTH = 1K
  FUSE            (rw!x) : ORIGIN = 0x820000, LENGTH = 1K
  LOCK            (rw!x) : ORIGIN = 0x830000, LENGTH = 1K
  SIGNATURE       (rw!x) : ORIGIN = 0x840000, LENGTH = 1K
  USER_SIGNATURES (rw!x) : ORIGIN = 0x850000, LENGTH = 1K
}

SECTIONS
{

    .text : 
    {

        /**
        * must place the reset vector at the beginning of the .text section
        **/
        crt.o(.vectors)
        KEEP(crt.o(.vectors))

        /**
        * section contains the  function that will be called by the reset vector
        * sets status register to 0 and initialize the stack pointer
        **/
        crt.o(.bad_interrupt)
        KEEP(crt.o(.bad_interrupt))
        
        /** 
        * section contains weak symbol for __init that will ensure reset vector 
        * jumps to __init function if it is not redefined by the user. __init is 
        * defined in crt.s
        **/
        crt.o(.init)
        KEEP(crt.o(.init))

        /**
        * section that contains the routines to load the data section from flash to ram
        * and to zero out the bss section
        **/
        crt.o(.load_data)
        KEEP(crt.o(.load_data))

        /**
        * section that contains the routines to zero out the bss section
        **/
        crt.o(.zero_bss)
        KEEP(crt.o(.zero_bss))

        /**
        * section that contains the routines to call the main function and
        * loop indefinitely if main returns
        **/
        crt.o(.call_main)
        KEEP(crt.o(.call_main))

        *(.text)
        *(.text.*)

        /**
        * if object files are included (other than main.o) we will include the text sections here.
        * We could also get rid of the main.o wildcards above and accumulate all the text sections here.
        **/
        *(.text)

        /**
        * Here we will include the .rodata section. This section contains read only data 
        * that lives only in flash.
        **/
        *(.rodata)
        *(.rodata.*)
        KEEP(*(.rodata))

        /**
        * include the version information for crt.s
        **/
        crt.o(.crt_version)
        KEEP(crt.o(.crt_version))

        . = ALIGN(2);
        _text_end = .;
    }> FLASH

    /**
    * The AT(ADDR(.text) + SIZEOF (.text)) describes the load address of the .data section.
    * This is where the .data section will be placed in flash. However the virtual memory address (runtime address)
    * will be the ORIGIN defined by the MEMORY directive above.
    **/
    .data : AT (ADDR(.text) + SIZEOF (.text)) 
    {
        /**
        * __data_start_sram will be the offset into the .data section from the virtual
        * memory address (0x800100) therefore this is the start address of data in sram.
        * same logic applies to __data_end_sram.
        **/
        __data_start_sram = .;
        *(.data)
        . = ALIGN(2);
        __data_end_sram = .;
    }> SRAM

    .bss : 
    {
        __bss_start_sram = .;
        *(.bss)
        *(.bss*)
        *(COMMON)
        __bss_end_sram = .;
    }> SRAM
    __HEAP_START = .;

    /**
     * Data Section Memory Management
     * -----------------------------
     * The .data section has two important addresses:
     * 1. Load Address (in Flash): Where the data is stored in program memory
     * 2. Runtime Address (in SRAM): Where the data will be accessed during execution
     *
     * These symbols are used by the crt.s initialization code to:
     * - Copy initialized data from Flash to SRAM during startup
     * - Set up the correct memory layout for the program
     *
     * Symbol Definitions:
     * - __data_start_flash: Starting address of .data section in Flash memory
     * - __data_end_flash: End address of .data section in Flash memory
     * - __data_bytes_to_read: Total size of .data section to be copied
     * - __bss_bytes_to_clear: Total size of .bss section to be zeroed
     *
     * Memory Layout:
     * - Flash: Program memory where the data is initially stored
     * - SRAM: Runtime memory where the data will be accessed
     * - The data is copied from Flash to SRAM during program initialization
     **/
    __data_start_flash = LOADADDR(.data);
    __data_end_flash = __data_start_flash + SIZEOF(.data);
    __data_bytes_to_read = SIZEOF(.data);
    __bss_bytes_to_clear = SIZEOF(.bss);
}

